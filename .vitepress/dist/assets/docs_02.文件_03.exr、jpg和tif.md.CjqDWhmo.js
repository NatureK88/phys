import{_ as e,c as a,o as t,a2 as r}from"./chunks/framework.m7XgQIAO.js";const b=JSON.parse('{"title":"标题","description":"","frontmatter":{"comment":null,"creation_date":"2024-05-24 14:22","lastmodify_date":"2024-05-27 15:18","progress":3,"score":3,"thumbnail":null,"sidebarDepth":2},"headers":[],"relativePath":"docs/02.文件/03.exr、jpg和tif.md","filePath":"docs/02.文件/03.exr、jpg和tif.md"}'),o={name:"docs/02.文件/03.exr、jpg和tif.md"},s=r('<h1 id="标题" tabindex="-1">标题 <a class="header-anchor" href="#标题" aria-label="Permalink to &quot;标题&quot;">​</a></h1><h2 id="_2" tabindex="-1">2 <a class="header-anchor" href="#_2" aria-label="Permalink to &quot;2&quot;">​</a></h2><p>fasfsef</p><h3 id="_3" tabindex="-1">3 <a class="header-anchor" href="#_3" aria-label="Permalink to &quot;3&quot;">​</a></h3><p>dsdfds</p><h4 id="_4" tabindex="-1">4 <a class="header-anchor" href="#_4" aria-label="Permalink to &quot;4&quot;">​</a></h4><p>exr 记录的光强是真实光强，上限是 $\\infty$，因此文件很大，blender 底层对光线和色彩的处理都是真实光强，在做光线追踪时，真实光强才能模拟出准确的效果。注意，虽然我们导入 blender 后看到的 exr 图还是在 0~1 范围内，那是因为显示器只能显示 0~1，1 代表显示器的最大亮度，不同的显示器不同，我们看到的图是 exr 原始数据映射后的结果。</p><p>jpg 是压缩后的图，所谓的压缩即把真实的光强通过函数压缩成 0~1，压缩的方式不是线性的，而是凸曲线，横轴代表真实光强，纵轴代表处理后的结果，因此强度较大的部分映射的结果几乎一样，接近 1，这也符合人眼的特点，看 10w 和 20w 的灯，差别很明显，看 1000w 和 1010w 的差别很小。这样的压缩方式可以省去很多空间。但是，如果用.webp 做光照贴图，就有问题了，因为即使我们知道.webp 映射曲线，也没有办法原样映射回去。比如，假设计算机显示光强的最小分辨率是 0.001，也就是说如果我们有真实光强为 10000 和 10100 的光源，都映射到了 0.991 这个值，那么我们即使逆运算，也分辨不出这两个光源的，这就是细节的丢失。</p><p>至于图像颜色变暗，是因为，blender 会默认将输入的图视为真实光强，进行一次到屏幕光强的映射，自然变暗了。如果我们想要通过.webp 来恢复真实光强，可以色彩映射选 sRGB，就不会做一次额外映射了，或者想办法把.webp 通过个逆运算映射回真实光强，虽然会丧失细节，但是效果会离真实光照更近。</p><p>tif 格式是可以记录多个图层的信息，因此修改可以无损。比如.webp，如果一张图，修改需要加入一盏强灯，那么由于映射凸曲线的关系，整幅会变暗，当我们保存后再去除强灯再保存，那么原本的图的色彩又由较低的亮度扩展到较高的亮度，但是细节就丧失了，比如原本 0.79 和 0.80 都映射到 0.4，反向扩张后只能都归到 0.8。多层可以减少这种问题，因为灯存在另一个图层中，并不改变 0.79 和 0.80 那个图层的状态，只是在输出的时候进行一次合成，当我们再去除强灯的时候，只是去掉了那个图层，恢复到原来的状态，所以是无损的。</p>',10),i=[s];function n(_,d,p,l,c,h){return t(),a("div",null,i)}const m=e(o,[["render",n]]);export{b as __pageData,m as default};
